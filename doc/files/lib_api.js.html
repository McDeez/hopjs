<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/api.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Hop.html">Hop</a></li>
            
                <li><a href="../classes/Hop.CodeGenerator.html">Hop.CodeGenerator</a></li>
            
                <li><a href="../classes/Hop.Method.html">Hop.Method</a></li>
            
                <li><a href="../classes/Hop.Object.html">Hop.Object</a></li>
            
                <li><a href="../classes/Hop.StubRequest.html">Hop.StubRequest</a></li>
            
                <li><a href="../classes/Hop.StubResponse.html">Hop.StubResponse</a></li>
            
                <li><a href="../classes/Hop.TestCase.html">Hop.TestCase</a></li>
            
                <li><a href="../classes/Hop.TestTask.html">Hop.TestTask</a></li>
            
                <li><a href="../classes/Hop.TestUtils.html">Hop.TestUtils</a></li>
            
                <li><a href="../classes/Hop.User.html">Hop.User</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Cache.html">Cache</a></li>
            
                <li><a href="../modules/CodeGenerator.html">CodeGenerator</a></li>
            
                <li><a href="../modules/Event.html">Event</a></li>
            
                <li><a href="../modules/Hop.html">Hop</a></li>
            
                <li><a href="../modules/Job.html">Job</a></li>
            
                <li><a href="../modules/Test.html">Test</a></li>
            
                <li><a href="../modules/User.html">User</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/api.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
	Hop Core module

	This is the primary impelementation behind Hop

	@module Hop
**/
var crypto = require(&#x27;crypto&#x27;);
var util = require(&#x27;hopjs-common&#x27;);

/*
	- display docs
	- enable unit tests
	- log functions
	- protect docs /w password
	- site name
	- readme.md
	- doc.css
	- 
*/

var Hop=function(){
	this.objects={};
	this.interfaces={};
}

Hop.use=function(what){
	what(Hop);
}

Hop.log=console.log;
Hop.error=console.error;
Hop.warn=console.warn;

/**
 	Given a string representation of a stack for a trace made during a call, return a more focused stack trace

	This function will attempt to cull a larger stack trace into something more relevant for what went on during
	a call. 

	@param {String} errorStack a stack trace captured from an error

	@returns stack a focused stack trace

*/
Hop.callStack=function(errorStack){
		var lines = errorStack.split(&quot;\n&quot;);
		var stack=[];
		var capture=false;
		for(var i=lines.length-1;i&gt;0;i--){
			var l = lines[i];
			var f = (l.replace(/^\s+at\s+([^ ]+).+/,&quot;$1&quot;));
			if(f==&quot;Hop_call_preTask&quot;){
				capture=true;
			}
			if(f==&quot;Hop_call_postTask&quot;){
				capture=false;
			}	
			if(capture==true &amp;&amp; f.indexOf(&quot;Hop_call&quot;)!=0){
				stack.push(l);
			} 
		}	
		return stack.join(&quot;\n&quot;);
}

Hop.logCall=function(method,type,err,result){
	var error = new Error();
	var stack = Hop.callStack(error.stack);
	Hop[type](method,err+&quot;\n&quot;+stack);
}


Hop.sendFile=function(file,options){
	return new Hop.File(file,options);
}

Hop.sendAttachment=function(file,options){
	options=options||{};
	options.attachment=true;	
	return new Hop.File(file,options);
}

Hop.render=function(template,input){
	return new Hop.Template(template,input);
}

Hop.Template=function(templateName,input){
	this.template=templateName;
	this.input=input;
}

Hop.Template.prototype.send=function(response){
	response.render(this.template,this.input);
}

Hop.File=function(file,options){
	this.file=file;
	this.options=options||{};
}

Hop.File.prototype.send=function(response){
	var filename = this.file || this.options.filename;
	if(this.options.attachment==true)
		response.download(this.file,filename);
	else
		response.sendfile(this.file);
}


Hop.Objects={};
Hop.Interfaces={};


/**
	Calculate a checksum for the Hop 

	This is used to detect changes in the version of the Hop

	@for Hop
	@method checksum
	@static
**/
Hop.checksum = function(){
	if(Hop._checksum)
		return Hop._checksum;
	var md5 = crypto.createHash(&#x27;md5&#x27;);	
	md5.update(Hop.toJSON(true));

	Hop._checksum = md5.digest(&#x27;hex&#x27;);
	return Hop._checksum;
}

/**
	Utility class for providing mock response objects

	@class Hop.StubResponse
**/
Hop.StubResponse=function(){
	this.header={};
}

Hop.StubResponse.prototype.set=function(name,value){
	this.header[name]=value;
}

Hop.StubResponse.prototype.get=function(name){
	return this.header[name];
}


/**
	Utility class for providing mock request objects

	@class Hop.StubRequest
**/
Hop.StubRequest=function(){
	this.header={};
	this.response = new Hop.StubResponse();
	this.session={};
}

Hop.StubRequest.prototype.getResponse=function(){
	return this.response;
}

Hop.StubRequest.prototype.set=function(name,value){
	this.header[name]=value;
}

Hop.StubRequest.prototype.get=function(name){
	return this.header[name];
}


Hop.getTemplates=function(obj,when,type){
	if(!obj._templates)
		return null;
	if(!obj._templates[type])
		return null;
	if(!obj._templates[type][when])
		return null;
	return obj._templates[type][when];
}

Hop.renderTemplates=function(obj,when,type,input){
	try {
		if(!obj._templates)
			return &quot;&quot;;
		if(!obj._templates[type])
			return &quot;&quot;;
		if(!obj._templates[type][when])
			return &quot;&quot;;
	

		var _input={};
		for(var i in input){
			_input[i]=input[i];
		}
		_input.Hop=Hop;
	
		var out = &quot;&quot;;
		obj._templates[type][when].map(function(template){
			out+=(Hop.renderTemplate(template)(_input));
		});
		return out;
	} catch(e){ 
		console.error(e);
		console.error(e.stack);
	}
}

Hop.addTemplate=function(obj,when,type,template){
	if(!obj._templates)
		obj._templates={};
	if(!obj._templates[type])
		obj._templates[type]={};
	if(!obj._templates[type][when])
		obj._templates[type][when]=[];
	if(obj._templates[type][when].indexOf(template)==-1){
		obj._templates[type][when].push(template);
	}
}

Hop.renderBeforeTemplates=function(type,input){
	return Hop.renderTemplates(Hop,&quot;before&quot;,type,input);
}	
Hop.renderAfterTemplates=function(type,input){
	return Hop.renderTemplates(Hop,&quot;after&quot;,type,input);
}	

Hop.getBeforeTemplates=function(type){
	return Hop.getTemplates(Hop,&quot;before&quot;,type);
}	

Hop.getAfterTemplates=function(type){
	return Hop.getTemplates(Hop,&quot;after&quot;,type);
}	

Hop.addBeforeTemplate=function(type,template){
	Hop.addTemplate(Hop,&quot;before&quot;,type,template);
}

Hop.addAfterTemplate=function(type,template){
	Hop.addTemplate(Hop,&quot;after&quot;,type,template);
}


/**
Define a new class 

* Use #classname to have the class name substituted into the URL

@param {string} name the name of the class
@param {object} [instance] an instance of the object
@param {function} onDefine the lambda used to define the interface

@example
	Hop.defineClass(&quot;Email&quot;,new Email(),function(api){
		//define the class 
	});


@for Hop
@method defineClass
@static
**/
Hop.defineClass=function(name,instance,onDefine){
	delete Hop._checksum;
	var api = new Hop.Object(name,instance);
	api.setLocalInterface();
	onDefine(api);
}

/**
Define a new interface

* Use #classname to have the class name substituted into the URL

@param {string} name the name of the interface
@param {function} onDefine the lambda used to define the interface

@example
	Hop.defineInterface(&quot;Notification&quot;,function(api){
		api.post(&quot;send&quot;,&quot;#classname/send&quot;).usage(&quot;Sends a message&quot;).demand(&quot;msg&quot;).demand(&quot;subject&quot;).demand(&quot;to&quot;);
	}


@for Hop
@method defineInterface 
@static
**/
Hop.defineInterface=function(name,onDefine){
	delete Hop._checksum;
	var intf = new Hop.Interface(name,onDefine);
}

Hop.toJSON=function(noChecksum){
		var obj = {};

		obj.Objects=Hop.Objects;
		obj.basePath = Hop.basePath;
		if(noChecksum!=true)
			obj.checksum = Hop.checksum();


		for(var i in this._toJSONHandler){
			var handler = this._toJSONHandler[i];
			handler(obj);	
		}	

		return JSON.stringify(obj,function(key,value){
				if(/^_/.test(key)){
					return undefined;
				} 
				return value;
		},&quot; &quot;);
}

Hop.fromJSON=function(jsonString){
	if(typeof jsonString==&quot;object&quot;)
		var obj = jsonString;
	else if(typeof jsonString==&quot;string&quot;)
		var obj = JSON.parse(jsonString);

	
	if(obj.Objects){
		for(var objectName in obj.Objects){
			var _object = obj.Objects[objectName];
			var object = new Hop.Object(objectName);
				
			for(var j in _object){
				object[j]=_object[j];
			}
			for(var methodName in obj.Objects[i].methods){
				var _method = obj.Objects[i].methods[methodName];
				var method = new Hop.Method(_method.method,object,_method.name,_method.path);
				object[_method.name]=method;
				
				for(var j in _method){
					method[j]=_method[j];
				}


			}
		}
	}
	
}


/**
	Add a call back which will be called when a version of the API must be built from JSON

	@param {function} onJSON Callback to be called when a json version of Hop is requested
		@param {object} The stub object which is being populated for conversion to JSON

	@for Hop
	@method addToJSONHandler
	@static
**/
Hop.addToJSONHandler=function(onJSON){
	if(!this._fromJSONHandler){
		this._fromJSONHandler=[];
	}
	this._fromJSONHandler.push(onJSON);
}

/**
	Add a call back which will be called when a JSON version of the API is requested

	@param {function} onJSON Callback to be called when a json version of Hop is requested
		@param {object} The stub object which is being populated for conversion to JSON

	@for Hop
	@method addToJSONHandler
	@static
**/
Hop.addToJSONHandler=function(onJSON){
	if(!this._toJSONHandler){
		this._toJSONHandler=[];
	}
	this._toJSONHandler.push(onJSON);
}


Hop.Interface = function(name,onDefine){
	this.onDefine=onDefine;
	this.name=name;
	Hop.Interfaces[name]=this;
}

/** 
	Defines an object

	This object is created by .defineClass

	@class Hop.Object
**/
Hop.Object = function(name,instance){
	this.name=name;
	this._instance=instance;
	this.methods={};
	Hop.Objects[name]=this;
}

/**
	Wrap an object so that it may be called localy with all of the functionality that Hop normally provides

	This function will create a wrapped version of a defined object with all of the functionality that Hop would normally provide. 

	@example
		Hop.defineClass(&quot;UserService&quot;,function(api){
			api.get(&quot;load&quot;,&quot;/user/:userID&quot;).demand(&quot;userID&quot;).cacheId(&quot;/user/:userID&quot;);
		});

		var userService = Hop.Object.wrap(&quot;UserService&quot;);

		//This call will now be subject to all of the normal constraints and functionality provided by Hop
		userService.load({ userID:5 },function(err,result){

		},request);

	@param {String} objectName Then name of the object to wrap


	@returns {Object} 
		An object with implementations of all the functions defined by the object. 
		The returned functions will have the calling signature (input,onComplete,request)


	@method Hop.Object.wrap
**/
Hop.Object.wrap=function(objectName){
	var result = {};

	var obj = Hop.Object.findObject(objectName);
	if(obj){
		for(var i in obj.methods){
			var method = obj.methods[i];
			(function(method){
				result[method.name]=function(input,onComplete,request){
					Hop.log(method.getMethod(),input,onComplete,request);
					Hop.call(method.getMethod(),input,onComplete,request);
				};	
			})(method);
		}	
	} else throw &quot;Invalid object name specified&quot;;
	return result;
}



Hop.Object.prototype.callOnError=function(method,request,input,error,stack){
	if(!stack){
		var exp = new Error();
		var stack = Hop.callStack(exp.stack);
	} else {
		stack = Hop.callStack(stack);
	}
	if(this.onError){
		var res = this.onError(method,request,input,error,stack);
		if(res!==null)
			return res;
	}
	Hop.error(method.getMethod(),&quot;:returned an error result of &#x27;&quot;+error+&quot;&#x27;\n&quot;+stack);
	return error;
}

/**
	Provide a function that will be called when an error occured for any call in the class

	This function can be used to filter error messages. A typical use case would be to have a small
	set of allowed error messages, and return a generic error message in all other cases. Or to attach 
	a unique number to each error and provide details in the console log. This function should return a string 
	for the desired error string or null if no custom error is returned. This function is not asynchronous.

	@param {Function} onError function to be called when an error has occured
		@param {Object} onError.method The method call associated with the error
		@param {Object} onError.request The request for the call
		@param {Object} onError.input The input for the call
		@param {String} onError.error The error string
		@param {String} onError.stack A stack trace of where the error occured
	

	@example
		Hop.defineClass(&quot;UserService&quot;,function(api){
			api.post(&quot;update&quot;,&quot;/user/:userID&quot;);
			
			api.errorHandler(function(method,request,input,error,stack){
				//If we know what the error is simply return it
				if(allowedErrors.contains(error)){
					return null;
				} else {
					//If we don&#x27;t recognize the error produce a unique ID for it and spit it out in the logs
					var id = Date.now();
					var err = &quot;Error (&quot;+id+&quot;)&quot;;
					Log.error(method.getName(),request,input,id,error,stack);
					return err;
				}
			});
		});
	
	@for Hop.Object
	@method errorHandler
 */
Hop.Object.prototype.errorHandler=function(onError){
	this.onError=onError;
}

Hop.Object.prototype.setLocalInterface=function(){
	this._localInterface=true;
}

Hop.Object.prototype.isLocalInterface=function(){
	return this._localInteraface===true;
}

Hop.Object.prototype.renderBeforeTemplates=function(type,input){
	return Hop.renderTemplates(this,&quot;before&quot;,type,input);
}	
Hop.Object.prototype.renderAfterTemplates=function(type,input){
	return Hop.renderTemplates(this,&quot;after&quot;,type,input);
}	

Hop.Object.prototype.getBeforeTemplates=function(type){
	return Hop.getTemplates(this,&quot;before&quot;,type);
}	

Hop.Object.prototype.getAfterTemplates=function(type){
	return Hop.getTemplates(this,&quot;after&quot;,type);
}	


Hop.Object.prototype.addBeforeTemplate=function(type,template){
	Hop.addTemplate(this,type,&quot;before&quot;,type,template);
}

Hop.Object.prototype.addAfterTemplate=function(type,template){
	Hop.addTemplate(this,type,&quot;after&quot;,type,template);
}


/**
Have this object extend from an interface

@example
	Hop.defineInterface(&quot;Notification&quot;,function(api){
		api.post(&quot;send&quot;,&quot;#classname/send&quot;).usage(&quot;Sends a message&quot;).demand(&quot;msg&quot;).demand(&quot;subject&quot;).demand(&quot;to&quot;);
	}
	Hop.defineClass(&quot;Email&quot;,function(api){
		//This will essentially evaluate the interface defined above against thsi class adding the send function
		api.extend(&quot;Notification&quot;);
	});

@for Hop.Object
@method extend
**/
Hop.Object.prototype.extend=function(intf){
	if(!this.interfaces){
		this.interfaces={};
	}
	this.interfaces[intf]=true;
	if(Hop.Interfaces[intf]){
		Hop.Interfaces[intf].onDefine(this);	
	} else throw (&quot;Invalid interface specified:&quot;+intf);
}

/**
Define a HTTP get call on this method

@params {String} method The name of the method on the associated object
@params {String} path The HTTP path that this call can be found on. Variables can be specified as part of the path utilizing &#x27;:&#x27;

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.get(&quot;load&quot;,&quot;/user/:userID&quot;);
		//..
	});

@for Hop.Object
@method get
@chainable
**/
Hop.Object.prototype.get=function(name,path){
	this.methods[name]=new Hop.Method(&quot;get&quot;,this,name,path);			
	return this.methods[name];
}	

/**
Define a HTTP post call on this method

@params {String} method The name of the method on the associated object
@params {String} path The HTTP path that this call can be found on. Variables can be specified as part of the path utilizing &#x27;:&#x27;

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.post(&quot;update&quot;,&quot;/user/:userID&quot;);
		//..
	});

@for Hop.Object
@method post
@chainable
**/
Hop.Object.prototype.post=function(name,path){
	this.methods[name]=new Hop.Method(&quot;post&quot;,this,name,path);			
	return this.methods[name];
}	

/**
Define a HTTP del call on this method

@params {String} method The name of the method on the associated object
@params {String} path The HTTP path that this call can be found on. Variables can be specified as part of the path utilizing &#x27;:&#x27;

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.del(&quot;delete&quot;,&quot;/user/:userID&quot;);
		//..
	});

@for Hop.Object
@method del
@chainable
**/
Hop.Object.prototype.del=function(name,path){
	this.methods[name]=new Hop.Method(&quot;delete&quot;,this,name,path);			
	return this.methods[name];
}	


/**
Define a HTTP put call on this method

@params {String} method The name of the method on the associated object
@params {String} path The HTTP path that this call can be found on. Variables can be specified as part of the path utilizing &#x27;:&#x27;

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.put(&quot;create&quot;,&quot;/user/&quot;);
		//..
	});

@for Hop.Object
@method put
@chainable
**/
Hop.Object.prototype.put=function(name,path){
	this.methods[name]=new Hop.Method(&quot;put&quot;,this,name,path);			
	return this.methods[name];
}	

/**
Define the usage for this class 

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.usage(&quot;Manages Users&quot;);
		//..
	});

@for Hop.Object
@method usage
@chainable
**/
Hop.Object.prototype.usage=function(usage){
	this.desc=usage;
	return this;
}

/**
Find an object by name

@return {string} The name of the method

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.get(&quot;load&quot;,&quot;/user/:userID&quot;)

	});
	var method = Hop.Method.findMethod(&quot;UserService.load&quot;);
	Hop.log(method.getMethod()); //returns UserService.load

@for Hop.Object
@method findObject
@static
**/
Hop.Object.findObject=function(objName){
	if(objName.indexOf(&quot;.&quot;)!=-1){
			var parts = objName.split(&quot;.&quot;);	
			objName = parts.splice(0,parts.length-1).join(&quot;.&quot;);
	}
	return Hop.Objects[objName];
}

/**
	Class used to define methods

	@class Hop.Method
	@constructor
**/
Hop.Method = function(method,object,name,_path){
	this._className = object.name;
	this.method=method;
	this.name=name;
	this.path=_path;
	this.params={};
	this._preCall=[];
	this._postCall=[];
	this.defaults={};
	this.options={};
	this.fullPath = Hop.Method.getPath(Hop.basePath,this._className,this);

	//Let&#x27;s figure out what parameters we must have!
	var self=this;
	var pathParts = _path.split(&quot;/&quot;);
	pathParts.map(function(part){
		if(/^:.*/.test(part)){
			self.demand(part.replace(/^:/,&quot;&quot;));
		}
	});

}

Hop.Method.prototype.toJSON=function(noChecksum){
	var obj = {};
	this.fullPath = Hop.Method.getPath(Hop.basePath,this._className,this);

	return this;
}


/**
Find a method by name

@return {string} The name of the method

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.get(&quot;load&quot;,&quot;/user/:userID&quot;)

	});
	var method = Hop.Method.findMethod(&quot;UserService.load&quot;);
	Hop.log(method.getMethod()); //returns UserService.load

@method findMethod
@static
**/
Hop.Method.findMethod=function(objName){
	var obj = Hop.Object.findObject(objName);
	if(obj){
		var parts = objName.split(&quot;.&quot;);
		var method = parts.splice(parts.length-1);
		return obj.methods[method];
	} else return null;
}

/**
Get the name of the method

This will get the name of the method

@return {string} The name of the method

@example
	Hop.defineClass(&quot;UserService&quot;,function(api){
		api.get(&quot;load&quot;,&quot;/user/:userID&quot;)

	});
	var method = Hop.Method.findMethod(&quot;UserService.load&quot;);
	Hop.log(method.getMethod()); //returns UserService.load

@method getMethod
**/
Hop.Method.prototype.getMethod=function(){
	return Hop.Method.getMethod(this._className,this);
}

Hop.Method.getMethod=function(className,method){
	return className+&quot;.&quot;+method.name;
}


/**
Get the full url for the method

This will get the full path for the url for the method.

@return {string} The URL for the method
@method getPath
**/
Hop.Method.prototype.getPath=function(){
	
	return Hop.Method.getPath(Hop.basePath,this._className,this);
}

Hop.Method.getPath=function(basePath,className,method){
	var _path = method.path.replace(&quot;#classname&quot;,className.toLowerCase());
	_path = _path.replace(&quot;#ClassName&quot;,className);
	return util.webpath.join(basePath,_path);
}

/**
Specify the default values for this call

These values will be copied into the input if no existing value is found.

@param {object} defaults
@method defaultValues
@chainable
**/
Hop.Method.prototype.defaultValues=function(defaults){
	this.defaults=defaults;
	return this;
}
/**
Specify a number of optionals for  for a call

@example
	api.post(&quot;create&quot;,&quot;/user/profile/&quot;).optionals(&quot;email&quot;,&quot;name&quot;,&quot;password&quot;);

@param {string} name of parameter (+)

@for Hop.Method
@method optionals
@chainable
**/
Hop.Method.prototype.optionals=function(){
	for(var i=0;i&lt;arguments.length;i++)
		this.optional(arguments[i]);	
	return this;
}

/**
Specify a number of demands for  for a call

@example
	api.post(&quot;create&quot;,&quot;/user/profile/&quot;).demands(&quot;email&quot;,&quot;name&quot;,&quot;password&quot;);

@param {string} name name of parameter (+)

@for Hop.Method
@method demands
@chainable
**/
Hop.Method.prototype.demands=function(){
	for(var i=0;i&lt;arguments.length;i++)
		this.demand(arguments[i]);	
	return this;
}

/**
Demand a parameter for a call

@example
	api.post(&quot;create&quot;,&quot;/user/profile/&quot;).demand(&quot;email&quot;,&quot;Email address&quot;);

@param {string} name of parameter
@param {string} desc description of parameter

@for Hop.Method
@method demand
@chainable
**/
Hop.Method.prototype.demand=function(name,desc,validate){
	this.params[name]={ desc: desc, validate: validate, demand:true };
	return this;
}

/**
	Describe this method

	@param {string} usage text describing the function for documentation purposes


	@chainable
	@method usage
**/
Hop.Method.prototype.usage=function(desc){
	this.desc=desc;
	return this;
}

/**
	Note that this method can only be called when there is a user in the session

	*This will only allow this method to be called if req.session.user exists*


	@example
		Hop.defineClass(&quot;UserService&quot;,UserService,function(api){
			//Only allow this method to be called if a user is in the session
			api.post(&quot;sendMsg&quot;,&quot;/user/:userId/message&quot;).authed();
		});

	@chainable
	@method authed 
**/
Hop.Method.prototype.authed=function(desc){
	this.authed=true;
	this.addPreCall(function Hop_Method_preCall_authed(req,input,onComplete,next){
		if(!req.session.user){
			return onComplete(&quot;Permission denied&quot;);
		} else return next();
	},&quot;demand&quot;);
	return this;
}



/**
	Note that this method can only be called using https

	@chainable
	@method secure 
**/
Hop.Method.prototype.secure=function(desc){
	this.secure=true;
	this.addPreCall(function Hop_Method_preCall_secure(req,input,onComplete,next){
		if(!req.secure){
			return onComplete(&quot;Permission denied&quot;);
		} else return next();
	},&quot;demand&quot;);
	return this;
}

/**
	Include the express CSRF token in the response headers for this method

	The CSRF token is utilized to prevent cross site request forgery attacks, and is a middleware component
	for express. 

	See here for information: http://www.senchalabs.org/connect/middleware-csrf.html

	By default HopJS will attempt to utilize the CSRF functionality in express if it is enabled, but 
	some clients require a means to access the CSRF token, hence this function will will send the csrf token
	in the headers as &#x27;x-crsf-token&#x27;
	
	The primary usage for this function is with secure login functions

	@example
		Hop.defineClass(&quot;UserService&quot;,UserService,function(api){
			api.post(&quot;login&quot;,&quot;/login&quot;).demands(&quot;username&quot;,&quot;password&quot;).sendCSRFToken();
		});

	@chainable
	@method sendCSRFToken
**/
Hop.Method.prototype.sendCSRFToken=function(){
	this.sendsCSRFToken=true;
	this.addPostCall(function Hop_Method_postCall_sendCSRFToken(req,input,err,result,next){
		if(!err &amp;&amp; req.session._csrf){
			req._response.set(&#x27;X-CSRF-Token&#x27;,req.session._csrf);	
		}
		next();
	},&quot;last&quot;);
	return this;
}


/**
Optional parameter for a call

@example
	api.post(&quot;create&quot;,&quot;/user/profile/&quot;).optional(&quot;phoneNumber&quot;,&quot;Phone Number&quot;);

@param {string} name of parameter
@param {string} desc description of parameter

@for Hop.Method
@method optional
@chainable
**/
Hop.Method.prototype.optional=function(name,desc,validate){
	this.params[name]={ desc: desc, validate: validate, optional:true };
	return this;
}

/**
Indicate this function performs longPolling

@example
	api.get(&quot;status&quot;,&quot;/server/:serverID/status&quot;).longPoll();

@for Hop.Method
@method longPoll
@chainable
**/
Hop.Method.prototype.longPoll=function(){
	this.options.noCache=true;
	this.options.longPoll=true;
	return this;
}

/**
Indicate this function should avoid caching

@example
	api.post(&quot;create&quot;,&quot;/user/profile/&quot;).noCache();

@for Hop.Method
@method noCache
@chainable
**/
Hop.Method.prototype.noCache=function(){
	this.options.noCache=true;
	return this;
}

Hop.Method.prototype.renderBeforeTemplates=function(type,input){
	return Hop.renderTemplates(this,&quot;before&quot;,type,input);
}	
Hop.Method.prototype.renderAfterTemplates=function(type,input){
	return Hop.renderTemplates(this,&quot;after&quot;,type,input);
}	

Hop.Method.prototype.getBeforeTemplates=function(type){
	return Hop.getTemplates(this,&quot;before&quot;,type);
}	

Hop.Method.prototype.getAfterTemplates=function(type){
	return Hop.getTemplates(this,&quot;after&quot;,type);
}	

Hop.Method.prototype.addBeforeTemplate=function(type,template){
	Hop.addTemplate(this,&quot;before&quot;,type,template);
}

Hop.Method.prototype.addAfterTemplate=function(type,template){
	Hop.addTemplate(this,&quot;after&quot;,type,template);
}


/**
Demand a file be provided for this method.

@example
	api.post(&quot;create&quot;,&quot;/user/profile/&quot;).demandFile(&quot;avatar&quot;,&quot;Users avatar image&quot;);

@for Hop.Method
@method demandFile
@chainable
**/
Hop.Method.prototype.demandFile=function(name,desc,validate){
	this.params[name]={ desc: desc, validate: validate, demandFile:true, demand:true };
	return this;
}

/**
Specify that a file may optionally be provided as an input to this call.

@example
	api.post(&quot;create&quot;,&quot;/user/profile/&quot;).optionalFile(&quot;avatar&quot;,&quot;Users avatar image&quot;);

@for Hop.Method
@method optionalFile
@chainable
**/
Hop.Method.prototype.optionalFile=function(name,desc,validate){
	this.params[name]={ desc: desc, validate: validate, optionalFile:true };
	return this;
}

/**
Add a function that will be called after this call is completed

@param {function} call function to be called when this call is completed, which is passed the following parameters:
	@param {object} call.request	the ExpressJS / HTTP request object
	@param {object} call.input	the input parameters to the call
	@param call.err	the resulting err from the call
	@param {object} call.result - the result of the call
	@param {function} call.next - to be called when the callback is completed, causing the next call back to be called
@param {string} phase the phase in which this function will be called (see below)

*Phases*

	1. (Pre call phases)
	2. **CALL** 	
	3. first - called before any other phases
	4. data - data processing and conversion
	5. event - event emission
	6. cache - cache phase 
	7. last - called last


@example
	api.get(&quot;load&quot;,&quot;/user/:userID&quot;).addPostCall(function(req,input,err,result,next){
		//Let&#x27;s caclulate the users age:
		if(result &amp;&amp; result.birthdate){
			result.age = User.calculateAge(result.birthdate);
		}	
		next();
	},&quot;data&quot;);

@for Hop.Method
@method addPostCall
@chainable
**/
Hop.Method.postCallPhases = [ &quot;first&quot;, &quot;data&quot;, &quot;event&quot;, &quot;cache&quot;, &quot;last&quot; ];
Hop.Method.prototype.addPostCall=function(call,phase){
	if(Hop.Method.postCallPhases.indexOf(phase)==-1)
		throw &quot;Invalid post call phase specified &#x27;&quot;+phase+&quot;&#x27; valid phases are &quot;+Hop.Method.postCallPhases.join(&quot;, &quot;);
	this._postCall.push({ call: call, phase: phase });
	
	this._postCall.sort(function(a,b){
		var aPhase = Hop.Method.postCallPhases.indexOf(a.phase);
		var bPhase = Hop.Method.postCallPhases.indexOf(b.phase);
		if(aPhase &lt; bPhase){
			return -1;
		} else if(bPhase &gt; aPhase){
			return 1;
		} else return 0;
	});	
	return this;
}


/**
Add a function that will be called before this call is executed 

@param {function} call function to be called prior to when this call is executed , which is passed the following parameters:
	@param {object} call.request the ExpressJS / HTTP request object
	@param {object} call.input the input parameters to the call
	@param {function} call.onComplete to be called if the function wants to short circuit and return a result
	@param {function} call.next to be called when the callback is completed, causing the next call back to be called
@param {string} phase the phase in which this function will be called (see below)

*Phases*

	1. first - called first
	2. demand - verifies that the required parameters are in place 
	3. conversion - will convert the input types to the expected types
	4. validation - input validation 
	5. auth - authentication phase
	6. event - event emission
	7. cache - cache phase 
	8. last - the last set of calls to be called prior to the function call
	9. **CALL** 	
	10. (post calls)


@example
	api.get(&quot;load&quot;,&quot;/user/:userID&quot;).addPreCall(function(req,input,err,onComplete,next){
		//If we have a user allow this call to complete
		if(req &amp;&amp; req.session &amp;&amp; req.session.user){
			next();
		//If not return an error 
		} else {
			return onComplete(&quot;Permission denied&quot;);
		}
	},&quot;auth&quot;);

@for Hop.Method
@method addPreCall
@chainable
**/
Hop.Method.preCallPhases=[ &quot;first&quot;,&quot;demand&quot;, &quot;conversion&quot;, &quot;validation&quot;, &quot;auth&quot;, &quot;event&quot;,&quot;cache&quot;,&quot;last&quot;];
Hop.Method.prototype.addPreCall=function(call,phase){
	if(Hop.Method.preCallPhases.indexOf(phase)==-1)
		throw &quot;Invalid pre call phase specified &#x27;&quot;+phase+&quot;&#x27; valid phases are &quot;+Hop.Method.preCallPhases.join(&quot;, &quot;);
	this._preCall.push({ call: call, phase: phase });
	
	this._preCall.sort(function(a,b){
		var aPhase = Hop.Method.preCallPhases.indexOf(a.phase);
		var bPhase = Hop.Method.preCallPhases.indexOf(b.phase);
		if(aPhase &lt; bPhase){
			return -1;
		} else if(bPhase &gt; aPhase){
			return 1;
		} else return 0;
	});	

	return this;
}

/**
Indicate that this method call has been depricated

@for Hop.Method
@method depricated
@chainable
**/

Hop.Method.prototype.depricated=function(){
	this.depricated=true;
}

/**
Calls the specified method 

This function is provided so that all functionality around a specific call may be utilized. 

@param {string} name Name of the function to call
@param {object} input Input for the call
@param {function} callback for completion
	@param callback.err The error returned from the call
	@param callback.result The result returned from the call
@param {object} [request] ExpressJS/HTTP request object

@example
	var input = { username: &quot;cfox&quot;, email:&quot;cfox@gmail.com&quot;}
	Hop.call(&quot;UserService.create&quot;,input,function(err,res){
		Hop.log(err,res);
	});


@for Hop
@method call
@static
**/
Hop.call=function(name,input,onComplete,request){
	var output = {};

	
	var obj = Hop.Object.findObject(name);
	if(!obj)
		throw (&quot;Invalid object specified: &quot;+name);
	
	var method = Hop.Method.findMethod(name);
	
	if(!method)
		throw (&quot;Invalid method specified: &quot;+name);
	
	for(var paramName in method.defaults){
		output[paramName]=method.defaults[paramName];	
	}
	for(var paramName in method.params){
		var param = method.params[paramName];
		if(typeof input[paramName]!=&quot;undefined&quot;){
			output[paramName]=input[paramName];	
		}
	}
	
	for(var paramName in method.params){
		if(param.demand &amp;&amp; typeof output[paramName]==&quot;undefined&quot;)
			throw (&quot;Missing parameter:&quot; +paramName);
	}


	if(obj._instance){
		if(!obj._instance[method.name])
			throw (&quot;Method not found on object instance: &quot;+method.name);
				
			var preTasks = method._preCall.length;
			var runPreTaskFunctions=function Hop_call_preTask(){
				if(preTasks&gt;0){
					method._preCall[method._preCall.length-preTasks].call(request,output,onComplete,function Hop_call_preCall(){
						preTasks--;
						runPreTaskFunctions();
					});
				} else {
					obj._instance[method.name](output,function Hop_call_instance(err,result){
							var postTasks = method._postCall.length;
							var runPostTaskFunctions=function Hop_call_postTask(){
								if(postTasks&gt;0){
									method._postCall[method._postCall.length-postTasks].call(request,output,err,result,function Hop_call_postCall(){
										postTasks--;
										runPostTaskFunctions();
									});
								} else {
									return onComplete(err,result);
								}
							}	
							runPostTaskFunctions();			
					},request);
				}
			}	

			runPreTaskFunctions();			

	} else {
		//FIXME
		throw &quot;I don&#x27;t know what to do here&quot;;
	}

}

var Stream = require(&#x27;stream&#x27;);

Hop.DataEncoder=util.DataEncoder;


Hop.addslashes=function(string) {
		return string.replace(/\\/g, &#x27;\\\\&#x27;).
				replace(/\u0008/g, &#x27;\\b&#x27;).
				replace(/\t/g, &#x27;\\t&#x27;).
				replace(/\n/g, &#x27;\\n&#x27;).
				replace(/\f/g, &#x27;\\f&#x27;).
				replace(/\r/g, &#x27;\\r&#x27;).
				replace(/&#x27;/g, &#x27;\\\&#x27;&#x27;).
				replace(/&quot;/g, &#x27;\\&quot;&#x27;);
}
module.exports=Hop;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
